<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Battle City - Ultimate Version</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #000;
            color: #fff;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }

        .game-container {
            text-align: center;
            padding: 20px;
            position: relative;
        }

        #gameCanvas {
            border: 4px solid #4CAF50;
            background: #000;
            margin-bottom: 20px;
            transform: translate(0, 0);
            transition: transform 0.1s;
        }

        .ui {
            display: flex;
            justify-content: space-around;
            margin-bottom: 10px;
            font-size: 18px;
            font-weight: bold;
        }

        .controls {
            color: #888;
            font-size: 14px;
            margin-bottom: 10px;
        }

        .debug {
            color: #ff4444;
            font-size: 12px;
            margin-top: 10px;
        }

        .level-complete, .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 40px;
            border: 4px solid #4CAF50;
            border-radius: 10px;
            z-index: 100;
            display: none;
        }

        .game-over {
            border-color: #FF4444;
        }

        .level-complete h2, .game-over h2 {
            color: #4CAF50;
            margin-bottom: 20px;
            font-size: 36px;
        }

        .game-over h2 {
            color: #FF4444;
        }

        .level-complete p, .game-over p {
            margin-bottom: 30px;
            font-size: 20px;
        }

        .next-level-btn, .restart-btn {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 18px;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            transition: background 0.3s;
            margin: 5px;
        }

        .restart-btn {
            background: #FF4444;
        }

        .next-level-btn:hover {
            background: #45a049;
        }

        .restart-btn:hover {
            background: #cc3333;
        }

        .tank-counter {
            color: #FFD700;
            font-size: 16px;
        }

        .spawn-notification {
            position: absolute;
            top: 50px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.1);
            padding: 10px 20px;
            border-radius: 5px;
            font-size: 16px;
            display: none;
        }

        .shield-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 100, 255, 0.7);
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 14px;
            display: none;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <canvas id="gameCanvas" width="832" height="832"></canvas>
        <div class="ui">
            <div class="score">Очки: <span id="score">0</span></div>
            <div class="lives">Жизни: <span id="lives">3</span></div>
            <div class="level">Уровень: <span id="level">1</span></div>
            <div class="tank-counter">Танки: <span id="tanksLeft">20</span>/20</div>
        </div>
        <div class="controls">
            <p>Управление: WASD/Стрелки - движение, Space/Enter - стрельба</p>
        </div>
        <div class="debug" id="debugInfo"></div>

        <div class="shield-indicator" id="shieldIndicator">Щит: <span id="shieldTime">5.0</span>с</div>
        <div class="spawn-notification" id="spawnNotification">Появление танка!</div>

        <div class="level-complete" id="levelComplete">
            <h2>Уровень пройден!</h2>
            <p>Танки уничтожены: <span id="destroyedTanks">0</span>/20</p>
            <p>Очки: <span id="levelScore">0</span></p>
            <button class="next-level-btn" onclick="game.nextLevel()">Следующий уровень</button>
        </div>

        <div class="game-over" id="gameOver">
            <h2>Игра окончена!</h2>
            <p>Ваш счет: <span id="finalScore">0</span></p>
            <p>Уровень: <span id="finalLevel">1</span></p>
            <button class="restart-btn" onclick="game.restartGame()">Начать заново</button>
        </div>
    </div>

    <script>
        // === КОНСТАНТЫ ===
        const TILE_SIZE = 32;
        const TANK_SPEED = 3;
        const BULLET_SPEED = 8;
        const CANVAS_WIDTH = 832;
        const CANVAS_HEIGHT = 832;
        const FPS = 60;
        const FRAME_TIME = 1000 / FPS;
        const MAX_ENEMIES_ON_SCREEN = 4;
        const TOTAL_ENEMIES_PER_LEVEL = 20;
        const RESPAWN_DELAY = 3000;
        const SPAWN_ANIMATION_DURATION = 3000;
        const PLAYER_SHIELD_DURATION = 5000; // 5 секунд неуязвимости

        // === ВСПОМОГАТЕЛЬНЫЕ КЛАССЫ ===
        class Vector2 {
            constructor(x = 0, y = 0) {
                this.x = x;
                this.y = y;
            }

            add(other) {
                return new Vector2(this.x + other.x, this.y + other.y);
            }

            multiply(scalar) {
                return new Vector2(this.x * scalar, this.y * scalar);
            }

            equals(other) {
                return this.x === other.x && this.y === other.y;
            }
        }

        class Rectangle {
            constructor(x, y, width, height) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
            }

            intersects(other) {
                return this.x < other.x + other.width &&
                       this.x + this.width > other.x &&
                       this.y < other.y + other.height &&
                       this.y + this.height > other.y;
            }
        }

        const DIRECTIONS = {
            UP: new Vector2(0, -1),
            DOWN: new Vector2(0, 1),
            LEFT: new Vector2(-1, 0),
            RIGHT: new Vector2(1, 0)
        };

        // === ТОЧКИ СПАВНА ===
        const SPAWN_POINTS = [
            new Vector2(416, 100),    // Центр сверху
            new Vector2(732, 100),    // Правый верх
            new Vector2(100, 100)     // Левый верх
        ];

        let currentSpawnIndex = 0;

        function getNextSpawnPoint() {
            const point = SPAWN_POINTS[currentSpawnIndex];
            currentSpawnIndex = (currentSpawnIndex + 1) % SPAWN_POINTS.length;
            return point;
        }

        // === КЛАСС СИЛОВОГО ПОЛЯ ===
        class ShieldEffect {
            constructor(tank) {
                this.tank = tank;
                this.active = true;
                this.startTime = Date.now();
                this.duration = PLAYER_SHIELD_DURATION;
                this.radius = tank.size * 1.3;
            }

            update() {
                const elapsed = Date.now() - this.startTime;
                if (elapsed >= this.duration) {
                    this.active = false;
                }
                return this.active;
            }

            draw(ctx) {
                if (!this.active) return;

                const elapsed = Date.now() - this.startTime;
                const progress = elapsed / this.duration;
                const remaining = 1 - progress;

                ctx.save();
                ctx.translate(this.tank.position.x, this.tank.position.y);

                // Пульсирующий эффект
                const pulse = Math.sin(Date.now() * 0.01) * 0.2 + 0.8;
                const currentRadius = this.radius * pulse;

                // Градиентное силовое поле
                const gradient = ctx.createRadialGradient(0, 0, currentRadius * 0.3, 0, 0, currentRadius);
                gradient.addColorStop(0, 'rgba(0, 150, 255, 0.8)');
                gradient.addColorStop(0.7, 'rgba(0, 100, 255, 0.4)');
                gradient.addColorStop(1, 'rgba(0, 50, 255, 0.1)');

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(0, 0, currentRadius, 0, Math.PI * 2);
                ctx.fill();

                // Внешнее кольцо
                ctx.strokeStyle = `rgba(100, 200, 255, ${remaining * 0.8})`;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(0, 0, currentRadius, 0, Math.PI * 2);
                ctx.stroke();

                // Энергетические частицы
                ctx.strokeStyle = `rgba(255, 255, 255, ${remaining * 0.6})`;
                ctx.lineWidth = 1;
                for (let i = 0; i < 12; i++) {
                    const angle = (i / 12) * Math.PI * 2 + progress * Math.PI;
                    const innerRadius = currentRadius * 0.7;
                    const outerRadius = currentRadius * 1.1;

                    const x1 = Math.cos(angle) * innerRadius;
                    const y1 = Math.sin(angle) * innerRadius;
                    const x2 = Math.cos(angle) * outerRadius;
                    const y2 = Math.sin(angle) * outerRadius;

                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.stroke();
                }

                ctx.restore();
            }

            getRemainingTime() {
                const elapsed = Date.now() - this.startTime;
                return Math.max(0, (this.duration - elapsed) / 1000);
            }
        }

        // === КЛАСС ЭФФЕКТА РАЗРУШЕНИЯ ПУЛИ ===
        class BulletExplosion {
            constructor(x, y) {
                this.position = new Vector2(x, y);
                this.particles = [];
                this.active = true;
                this.lifetime = 20;

                // Создаем частицы
                for (let i = 0; i < 8; i++) {
                    this.particles.push({
                        position: new Vector2(x, y),
                        velocity: new Vector2(
                            (Math.random() - 0.5) * 6,
                            (Math.random() - 0.5) * 6
                        ),
                        life: 20 + Math.random() * 10
                    });
                }
            }

            update() {
                this.lifetime--;
                if (this.lifetime <= 0) {
                    this.active = false;
                }

                this.particles.forEach(particle => {
                    particle.position = particle.position.add(particle.velocity);
                    particle.life--;
                    particle.velocity = particle.velocity.multiply(0.95); // Замедление
                });

                // Удаляем мертвые частицы
                this.particles = this.particles.filter(p => p.life > 0);
            }

            draw(ctx) {
                if (!this.active) return;

                this.particles.forEach(particle => {
                    const alpha = particle.life / 30;
                    ctx.fillStyle = `rgba(255, 255, 0, ${alpha})`;
                    ctx.beginPath();
                    ctx.arc(
                        particle.position.x,
                        particle.position.y,
                        2,
                        0,
                        Math.PI * 2
                    );
                    ctx.fill();
                });
            }
        }

        // === КЛАСС АНИМАЦИИ УНИЧТОЖЕНИЯ ===
        class Explosion {
            constructor(x, y, type = 'tank') {
                this.position = new Vector2(x, y);
                this.frame = 0;
                this.totalFrames = type === 'tank' ? 8 : 12;
                this.frameTime = 0;
                this.frameDelay = type === 'tank' ? 50 : 40;
                this.active = true;
                this.size = type === 'tank' ? TILE_SIZE * 1.5 : TILE_SIZE * 2;
                this.type = type;
            }

            update(deltaTime) {
                this.frameTime += deltaTime;
                if (this.frameTime >= this.frameDelay) {
                    this.frameTime = 0;
                    this.frame++;
                    if (this.frame >= this.totalFrames) {
                        this.active = false;
                    }
                }
            }

            draw(ctx) {
                if (!this.active) return;

                ctx.save();
                ctx.translate(this.position.x, this.position.y);

                const progress = this.frame / this.totalFrames;
                const scale = this.type === 'tank' ?
                    (0.5 + progress * 1.5) :
                    (0.3 + progress * 2.0);
                const alpha = 1 - progress * 0.8;

                ctx.globalAlpha = alpha;

                if (this.type === 'tank') {
                    if (this.frame % 2 === 0) {
                        ctx.fillStyle = '#FF4444';
                    } else {
                        ctx.fillStyle = '#FFAA00';
                    }

                    const radius = (this.size / 2) * scale;

                    ctx.beginPath();
                    ctx.arc(0, 0, radius, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillStyle = '#FFFF00';
                    for (let i = 0; i < 8; i++) {
                        const angle = (i / 8) * Math.PI * 2 + progress * Math.PI;
                        const flashRadius = radius * 0.7;
                        const flashSize = radius * 0.4;
                        const x = Math.cos(angle) * flashRadius;
                        const y = Math.sin(angle) * flashRadius;

                        ctx.beginPath();
                        ctx.arc(x, y, flashSize * (0.5 + Math.sin(progress * 10) * 0.5), 0, Math.PI * 2);
                        ctx.fill();
                    }
                } else {
                    ctx.fillStyle = '#FF4444';
                    const radius = (this.size / 2) * scale;

                    ctx.beginPath();
                    ctx.arc(0, 0, radius, 0, Math.PI * 2);
                    ctx.fill();

                    for (let i = 0; i < 3; i++) {
                        const circleProgress = progress - i * 0.2;
                        if (circleProgress > 0 && circleProgress < 0.8) {
                            ctx.fillStyle = i === 0 ? '#FFFF00' : i === 1 ? '#FFAA00' : '#FF4444';
                            const circleRadius = radius * (0.3 + circleProgress * 0.7);
                            ctx.globalAlpha = alpha * (1 - circleProgress);
                            ctx.beginPath();
                            ctx.arc(0, 0, circleRadius, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                }

                ctx.restore();
            }
        }

        // === КЛАСС АНИМАЦИИ ПОЯВЛЕНИЯ ТАНКА ===
        class SpawnAnimation {
            constructor(x, y) {
                this.position = new Vector2(x, y);
                this.progress = 0;
                this.duration = SPAWN_ANIMATION_DURATION;
                this.active = true;
                this.size = TILE_SIZE - 8;
            }

            update(deltaTime) {
                this.progress += deltaTime / this.duration;
                if (this.progress >= 1) {
                    this.active = false;
                }
            }

            draw(ctx) {
                if (!this.active) return;

                ctx.save();
                ctx.translate(this.position.x, this.position.y);

                const flashSpeed = 10;
                const visible = Math.floor(this.progress * flashSpeed) % 2 === 0;

                if (visible) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                    ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size);

                    const growProgress = this.progress * 2;
                    if (growProgress < 1) {
                        ctx.strokeStyle = '#4CAF50';
                        ctx.lineWidth = 3;
                        ctx.setLineDash([5, 5]);
                        const currentSize = this.size * growProgress;
                        ctx.strokeRect(-currentSize/2, -currentSize/2, currentSize, currentSize);
                        ctx.setLineDash([]);
                    }
                }

                ctx.restore();
            }
        }

        // === КЛАСС ПУЛИ ===
        class Bullet {
            constructor(x, y, direction, owner) {
                this.position = new Vector2(x, y);
                this.direction = direction;
                this.speed = BULLET_SPEED;
                this.owner = owner;
                this.size = 6;
                this.active = true;
            }

            update() {
                this.position = this.position.add(this.direction.multiply(this.speed));

                // Проверка границ с непроходимыми стенами
                if (this.position.x < TILE_SIZE || this.position.x > CANVAS_WIDTH - TILE_SIZE ||
                    this.position.y < TILE_SIZE || this.position.y > CANVAS_HEIGHT - TILE_SIZE) {
                    this.active = false;
                }
            }

            draw(ctx) {
                ctx.fillStyle = this.owner === 'player' ? '#FFFF00' : '#FF4444';
                ctx.beginPath();
                ctx.arc(this.position.x, this.position.y, this.size / 2, 0, Math.PI * 2);
                ctx.fill();

                ctx.strokeStyle = '#000';
                ctx.lineWidth = 1;
                ctx.stroke();
            }

            getBounds() {
                return new Rectangle(
                    this.position.x - this.size/2,
                    this.position.y - this.size/2,
                    this.size,
                    this.size
                );
            }
        }

        // === КЛАСС ТАНКА ===
        class Tank {
            constructor(x, y, type = 'player', level = 1) {
                this.position = new Vector2(x, y);
                this.direction = DIRECTIONS.UP;
                // На первом уровне враги в 2 раза медленнее
                this.speed = type === 'player' ? TANK_SPEED : (level === 1 ? TANK_SPEED * 0.35 : TANK_SPEED * 0.7);
                this.type = type;
                this.size = TILE_SIZE - 8;
                this.color = type === 'player' ? '#4CAF50' : '#FF4444';
                this.health = 1;
                this.reloadTime = 0;
                this.canShoot = true;
                this.username = type === 'enemy' ? `Enemy${Math.floor(Math.random() * 1000)}` : '';
                this.spawnProtection = type === 'enemy' ? 60 : 0;
                this.shield = null;
            }

            update() {
                if (this.spawnProtection > 0) {
                    this.spawnProtection--;
                }

                if (this.shield) {
                    if (!this.shield.update()) {
                        this.shield = null;
                    }
                }

                if (!this.canShoot) {
                    this.reloadTime--;
                    if (this.reloadTime <= 0) {
                        this.canShoot = true;
                    }
                }
            }

            activateShield() {
                this.shield = new ShieldEffect(this);
            }

            hasShield() {
                return this.shield !== null && this.shield.active;
            }

            move(newDirection, map, otherTanks = []) {
                const oldDirection = this.direction;
                this.direction = newDirection;

                const newPos = this.position.add(this.direction.multiply(this.speed));

                // Проверка границ игрового поля
                if (newPos.x < TILE_SIZE + this.size/2 || newPos.x > CANVAS_WIDTH - TILE_SIZE - this.size/2 ||
                    newPos.y < TILE_SIZE + this.size/2 || newPos.y > CANVAS_HEIGHT - TILE_SIZE - this.size/2) {
                    return false;
                }

                const tankBounds = new Rectangle(
                    newPos.x - this.size/2 + 2,
                    newPos.y - this.size/2 + 2,
                    this.size - 4,
                    this.size - 4
                );

                const mapCollision = map.checkCollision(tankBounds);

                let tankCollision = false;
                for (const otherTank of otherTanks) {
                    if (otherTank !== this && tankBounds.intersects(otherTank.getBounds())) {
                        tankCollision = true;
                        break;
                    }
                }

                if (!mapCollision && !tankCollision) {
                    this.position = newPos;
                    return true;
                } else {
                    this.direction = oldDirection;
                    const oldDirPos = this.position.add(this.direction.multiply(this.speed));
                    const oldBounds = new Rectangle(
                        oldDirPos.x - this.size/2 + 2,
                        oldDirPos.y - this.size/2 + 2,
                        this.size - 4,
                        this.size - 4
                    );

                    const oldMapCollision = map.checkCollision(oldBounds);
                    let oldTankCollision = false;
                    for (const otherTank of otherTanks) {
                        if (otherTank !== this && oldBounds.intersects(otherTank.getBounds())) {
                            oldTankCollision = true;
                            break;
                        }
                    }

                    if (!oldMapCollision && !oldTankCollision) {
                        this.position = oldDirPos;
                        return true;
                    }
                }
                return false;
            }

            shoot() {
                if (this.canShoot) {
                    this.canShoot = false;
                    this.reloadTime = this.type === 'player' ? 20 : 40;

                    const offset = this.direction.multiply(this.size / 2 + 5);
                    const bulletX = this.position.x + offset.x;
                    const bulletY = this.position.y + offset.y;

                    return new Bullet(bulletX, bulletY, this.direction, this.type);
                }
                return null;
            }

            takeDamage() {
                // Если есть щит - неуязвим
                if (this.hasShield()) {
                    return false;
                }

                this.health--;
                return this.health <= 0;
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.position.x, this.position.y);

                let angle = 0;
                if (this.direction === DIRECTIONS.RIGHT) angle = Math.PI / 2;
                else if (this.direction === DIRECTIONS.DOWN) angle = Math.PI;
                else if (this.direction === DIRECTIONS.LEFT) angle = -Math.PI / 2;

                ctx.rotate(angle);

                if (this.spawnProtection > 0 && this.spawnProtection % 10 < 5) {
                    ctx.globalAlpha = 0.5;
                }

                // Корпус танка
                ctx.fillStyle = this.color;
                ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size);

                // Детали корпуса
                ctx.fillStyle = this.type === 'player' ? '#388E3C' : '#CC3333';
                ctx.fillRect(-this.size/4, -this.size/4, this.size/2, this.size/2);

                // Дуло
                ctx.fillStyle = '#333';
                const barrelLength = this.size * 0.8;
                const barrelWidth = this.size * 0.25;
                ctx.fillRect(-barrelWidth/2, -barrelLength - 2, barrelWidth, barrelLength);

                ctx.restore();

                // Рисуем щит поверх танка
                if (this.shield) {
                    this.shield.draw(ctx);
                }

                if (this.type === 'enemy' && this.username) {
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                    const textWidth = ctx.measureText(this.username).width;
                    ctx.fillRect(
                        this.position.x - textWidth/2 - 2,
                        this.position.y - this.size - 22,
                        textWidth + 4,
                        16
                    );

                    ctx.fillStyle = '#FFF';
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(this.username, this.position.x, this.position.y - this.size - 10);
                }
            }

            getBounds() {
                return new Rectangle(
                    this.position.x - this.size/2,
                    this.position.y - this.size/2,
                    this.size,
                    this.size
                );
            }
        }

        // === КЛАСС КАРТЫ ===
        class GameMap {
            constructor(level = 1) {
                this.tileSize = TILE_SIZE;
                this.width = Math.floor(CANVAS_WIDTH / TILE_SIZE);
                this.height = Math.floor(CANVAS_HEIGHT / TILE_SIZE);
                this.grid = this.generateLevel(level);
                this.basePosition = new Vector2(Math.floor(this.width / 2), this.height - 2);
                this.baseDestroyed = false;
            }

            generateLevel(level) {
                const grid = Array(this.height).fill().map(() => Array(this.width).fill(0));

                // Границы из бетона (непроходимые и непробиваемые)
                for (let i = 0; i < this.width; i++) {
                    grid[0][i] = 5; // Бетон
                    grid[this.height-1][i] = 5;
                }
                for (let i = 0; i < this.height; i++) {
                    grid[i][0] = 5;
                    grid[i][this.width-1] = 5;
                }

                // Защищаем зоны спавна игрока (левый нижний угол)
                const playerSpawnArea = [
                    [6, 22], [7, 22], [8, 22], [9, 22],
                    [6, 23], [7, 23], [8, 23], [9, 23],
                    [6, 24], [7, 24], [8, 24], [9, 24],
                    [6, 25], [7, 25], [8, 25], [9, 25]
                ];

                playerSpawnArea.forEach(([x, y]) => {
                    if (x >= 0 && x < this.width && y >= 0 && y < this.height) {
                        grid[y][x] = 0;
                    }
                });

                // Защищаем зоны спавна врагов
                const enemySpawnAreas = [
                    // Центр
                    [11, 1], [12, 1], [13, 1], [14, 1],
                    [11, 2], [12, 2], [13, 2], [14, 2],
                    [11, 3], [12, 3], [13, 3], [14, 3],
                    // Право
                    [21, 1], [22, 1], [23, 1], [24, 1],
                    [21, 2], [22, 2], [23, 2], [24, 2],
                    [21, 3], [22, 3], [23, 3], [24, 3],
                    // Лево
                    [1, 1], [2, 1], [3, 1], [4, 1],
                    [1, 2], [2, 2], [3, 2], [4, 2],
                    [1, 3], [2, 3], [3, 3], [4, 3]
                ];

                enemySpawnAreas.forEach(([x, y]) => {
                    if (x >= 0 && x < this.width && y >= 0 && y < this.height) {
                        grid[y][x] = 0;
                    }
                });

                // Препятствия
                const obstacleCount = 12 + level * 3;
                for (let i = 0; i < obstacleCount; i++) {
                    const x = Math.floor(Math.random() * (this.width - 8)) + 4;
                    const y = Math.floor(Math.random() * (this.height - 12)) + 4;

                    // Проверяем, не в зоне спавна ли
                    let inSpawnArea = false;
                    for (const [sx, sy] of playerSpawnArea.concat(enemySpawnAreas)) {
                        if (x === sx && y === sy) {
                            inSpawnArea = true;
                            break;
                        }
                    }

                    if (!inSpawnArea && grid[y][x] === 0) {
                        // Разные типы препятствий в зависимости от уровня
                        const rand = Math.random();
                        if (rand < 0.6) grid[y][x] = 1; // Кирпич
                        else if (rand < 0.8) grid[y][x] = 3; // Вода
                        else grid[y][x] = 5; // Бетон

                        // Создаем небольшие группы из 4 сегментов
                        if (Math.random() > 0.4) {
                            const segments = [
                                [x, y], [x+1, y],
                                [x, y+1], [x+1, y+1]
                            ];

                            segments.forEach(([sx, sy]) => {
                                if (sx >= 0 && sx < this.width && sy >= 0 && sy < this.height) {
                                    // Проверяем, не в зоне спавна ли
                                    let segInSpawnArea = false;
                                    for (const [spx, spy] of playerSpawnArea.concat(enemySpawnAreas)) {
                                        if (sx === spx && sy === spy) {
                                            segInSpawnArea = true;
                                            break;
                                        }
                                    }
                                    if (!segInSpawnArea && grid[sy][sx] === 0) {
                                        grid[sy][sx] = grid[y][x];
                                    }
                                }
                            });
                        }
                    }
                }

                // Защита базы - кирпичные стены вокруг одного блока базы
                const baseX = Math.floor(this.width / 2);
                const baseY = this.height - 2;

                // Очищаем область вокруг базы (3x3)
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -1; dy <= 1; dy++) {
                        const x = baseX + dx, y = baseY + dy;
                        if (x >= 0 && x < this.width && y >= 0 && y < this.height) {
                            grid[y][x] = 0;
                        }
                    }
                }

                // Создаем кирпичные стены вокруг базы (полный квадрат)
                const wallPositions = [
                    // Левая стена
                    [baseX - 1, baseY - 1], [baseX - 1, baseY], [baseX - 1, baseY + 1],
                    // Правая стена
                    [baseX + 1, baseY - 1], [baseX + 1, baseY], [baseX + 1, baseY + 1],
                    // Верхняя стена
                    [baseX, baseY - 1],
                    // Нижняя стена
                    [baseX, baseY + 1]
                ];

                wallPositions.forEach(([x, y]) => {
                    if (x >= 0 && x < this.width && y >= 0 && y < this.height) {
                        grid[y][x] = 1; // Кирпич
                    }
                });

                // База - один центральный блок
                grid[baseY][baseX] = 4;

                return grid;
            }

            checkCollision(rect) {
                const startX = Math.max(0, Math.floor(rect.x / this.tileSize));
                const startY = Math.max(0, Math.floor(rect.y / this.tileSize));
                const endX = Math.min(this.width-1, Math.floor((rect.x + rect.width) / this.tileSize));
                const endY = Math.min(this.height-1, Math.floor((rect.y + rect.height) / this.tileSize));

                for (let y = startY; y <= endY; y++) {
                    for (let x = startX; x <= endX; x++) {
                        const tile = this.grid[y][x];
                        // Вода и пустые клетки проходимы для пуль, но вода непроходима для танков
                        if (tile === 1 || tile === 3 || tile === 4 || tile === 5) {
                            const tileRect = new Rectangle(
                                x * this.tileSize,
                                y * this.tileSize,
                                this.tileSize,
                                this.tileSize
                            );
                            if (rect.intersects(tileRect)) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            }

            destroyTile(x, y) {
                const tileX = Math.floor(x / this.tileSize);
                const tileY = Math.floor(y / this.tileSize);

                if (tileX >= 0 && tileX < this.width && tileY >= 0 && tileY < this.height) {
                    const tile = this.grid[tileY][tileX];

                    // Разрушаем только кирпичи и базу (бетон и вода не разрушаются)
                    if (tile === 1 || tile === 4) {
                        this.grid[tileY][tileX] = 0;

                        if (tile === 4) {
                            this.checkBaseDestruction();
                            return 'base';
                        }
                        return 'brick';
                    }
                    // Бетон не разрушается, но пуля уничтожается
                    else if (tile === 5) {
                        return 'concrete';
                    }
                }
                return false;
            }

            checkBaseDestruction() {
                const baseX = Math.floor(this.width / 2);
                const baseY = this.height - 2;

                // Проверяем только один блок базы
                if (this.grid[baseY][baseX] !== 4) {
                    this.baseDestroyed = true;
                }
            }

            isBaseDestroyed() {
                return this.baseDestroyed;
            }

            draw(ctx) {
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

                // Рисуем границы из бетона
                ctx.fillStyle = '#FFFFFF';
                for (let i = 0; i < this.width; i++) {
                    ctx.fillRect(i * TILE_SIZE, 0, TILE_SIZE, TILE_SIZE);
                    ctx.fillRect(i * TILE_SIZE, (this.height-1) * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                }
                for (let i = 0; i < this.height; i++) {
                    ctx.fillRect(0, i * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                    ctx.fillRect((this.width-1) * TILE_SIZE, i * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                }

                for (let y = 1; y < this.height - 1; y++) {
                    for (let x = 1; x < this.width - 1; x++) {
                        const tile = this.grid[y][x];
                        const tileX = x * this.tileSize;
                        const tileY = y * this.tileSize;

                        switch(tile) {
                            case 0:
                                break;
                            case 1: // Кирпич
                                ctx.fillStyle = '#D2691E';
                                ctx.fillRect(tileX, tileY, this.tileSize, this.tileSize);
                                ctx.strokeStyle = '#8B4513';
                                ctx.lineWidth = 1;
                                ctx.strokeRect(tileX, tileY, this.tileSize, this.tileSize);
                                // Разделительные линии
                                ctx.strokeStyle = '#A0522D';
                                ctx.beginPath();
                                ctx.moveTo(tileX, tileY + this.tileSize/2);
                                ctx.lineTo(tileX + this.tileSize, tileY + this.tileSize/2);
                                ctx.moveTo(tileX + this.tileSize/2, tileY);
                                ctx.lineTo(tileX + this.tileSize/2, tileY + this.tileSize);
                                ctx.stroke();
                                break;
                            case 3: // Вода
                                ctx.fillStyle = '#1E90FF';
                                ctx.fillRect(tileX, tileY, this.tileSize, this.tileSize);
                                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                                const waveTime = Date.now() * 0.002;
                                const waveOffset = Math.sin(waveTime + x * 0.5 + y * 0.3) * 2;
                                ctx.fillRect(tileX, tileY + waveOffset, this.tileSize, this.tileSize / 3);
                                break;
                            case 4: // База (один блок)
                                ctx.fillStyle = '#FFD700';
                                ctx.fillRect(tileX, tileY, this.tileSize, this.tileSize);
                                ctx.fillStyle = '#000';
                                ctx.font = '20px Arial';
                                ctx.textAlign = 'center';
                                ctx.fillText('★', tileX + this.tileSize/2, tileY + this.tileSize/2 + 7);
                                break;
                            case 5: // Бетон (белый с глянцем)
                                ctx.fillStyle = '#FFFFFF';
                                ctx.fillRect(tileX, tileY, this.tileSize, this.tileSize);
                                ctx.strokeStyle = '#CCCCCC';
                                ctx.lineWidth = 1;
                                ctx.strokeRect(tileX, tileY, this.tileSize, this.tileSize);

                                // Глянцевый эффект
                                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                                ctx.beginPath();
                                ctx.moveTo(tileX, tileY);
                                ctx.lineTo(tileX + this.tileSize, tileY);
                                ctx.lineTo(tileX, tileY + this.tileSize);
                                ctx.fill();

                                // Текстура бетона
                                ctx.fillStyle = 'rgba(200, 200, 200, 0.2)';
                                for (let i = 0; i < 3; i++) {
                                    for (let j = 0; j < 3; j++) {
                                        if ((i + j) % 2 === 0) {
                                            ctx.fillRect(
                                                tileX + i * this.tileSize/3 + 2,
                                                tileY + j * this.tileSize/3 + 2,
                                                this.tileSize/4,
                                                this.tileSize/4
                                            );
                                        }
                                    }
                                }
                                break;
                        }
                    }
                }
            }
        }

        // === ОСНОВНОЙ КЛАСС ИГРЫ ===
        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.level = 1;
                this.score = 0;
                this.lives = 3;
                this.gameOver = false;
                this.levelComplete = false;

                this.keys = {};
                this.debugInfo = document.getElementById('debugInfo');
                this.shieldIndicator = document.getElementById('shieldIndicator');
                this.shieldTime = document.getElementById('shieldTime');
                this.lastTime = 0;
                this.deltaTime = 0;
                this.directionPriority = null;

                this.enemiesDestroyed = 0;
                this.totalEnemies = TOTAL_ENEMIES_PER_LEVEL;
                this.enemiesToSpawn = TOTAL_ENEMIES_PER_LEVEL;
                this.lastRespawnTime = Date.now();

                this.explosions = [];
                this.bulletExplosions = [];
                this.spawnAnimations = [];
                this.screenShake = 0;

                this.initLevel();
                this.setupEventListeners();
                this.gameLoop(0);
            }

            initLevel() {
                this.map = new GameMap(this.level);
                // Спавн игрока слева от базы (координаты 224, 750)
                this.player = new Tank(224, 750);
                this.enemies = [];
                this.bullets = [];
                this.explosions = [];
                this.bulletExplosions = [];
                this.spawnAnimations = [];
                this.screenShake = 0;

                this.enemiesDestroyed = 0;
                this.enemiesToSpawn = TOTAL_ENEMIES_PER_LEVEL;
                this.lastRespawnTime = Date.now();
                this.levelComplete = false;
                this.gameOver = false;

                // Сбрасываем индекс спавна
                currentSpawnIndex = 0;

                this.updateUI();
                this.updateShieldIndicator();

                document.getElementById('levelComplete').style.display = 'none';
                document.getElementById('gameOver').style.display = 'none';
            }

            spawnEnemy() {
                if (this.enemiesToSpawn <= 0) return null;

                const spawnPoint = getNextSpawnPoint();

                this.spawnAnimations.push(new SpawnAnimation(spawnPoint.x, spawnPoint.y));
                this.showSpawnNotification();

                this.enemiesToSpawn--;
                this.updateUI();

                return spawnPoint;
            }

            completeSpawnAnimation(spawnPoint) {
                // Передаем уровень для определения скорости врагов
                const enemy = new Tank(spawnPoint.x, spawnPoint.y, 'enemy', this.level);
                enemy.direction = DIRECTIONS.DOWN;
                this.enemies.push(enemy);
            }

            showSpawnNotification() {
                const notification = document.getElementById('spawnNotification');
                notification.style.display = 'block';
                setTimeout(() => {
                    notification.style.display = 'none';
                }, 2000);
            }

            setupEventListeners() {
                document.addEventListener('keydown', (e) => {
                    this.keys[e.code] = true;

                    if (e.code === 'ArrowUp' || e.code === 'KeyW') {
                        this.directionPriority = DIRECTIONS.UP;
                    } else if (e.code === 'ArrowDown' || e.code === 'KeyS') {
                        this.directionPriority = DIRECTIONS.DOWN;
                    } else if (e.code === 'ArrowLeft' || e.code === 'KeyA') {
                        this.directionPriority = DIRECTIONS.LEFT;
                    } else if (e.code === 'ArrowRight' || e.code === 'KeyD') {
                        this.directionPriority = DIRECTIONS.RIGHT;
                    }

                    if(['Space','ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.code)) {
                        e.preventDefault();
                    }
                });

                document.addEventListener('keyup', (e) => {
                    this.keys[e.code] = false;

                    if ((e.code === 'ArrowUp' || e.code === 'KeyW') && this.directionPriority === DIRECTIONS.UP) {
                        this.directionPriority = null;
                    } else if ((e.code === 'ArrowDown' || e.code === 'KeyS') && this.directionPriority === DIRECTIONS.DOWN) {
                        this.directionPriority = null;
                    } else if ((e.code === 'ArrowLeft' || e.code === 'KeyA') && this.directionPriority === DIRECTIONS.LEFT) {
                        this.directionPriority = null;
                    } else if ((e.code === 'ArrowRight' || e.code === 'KeyD') && this.directionPriority === DIRECTIONS.RIGHT) {
                        this.directionPriority = null;
                    }
                });

                this.canvas.addEventListener('contextmenu', (e) => e.preventDefault());
            }

            getCurrentDirection() {
                if (this.directionPriority) {
                    return this.directionPriority;
                }

                if (this.keys['ArrowUp'] || this.keys['KeyW']) return DIRECTIONS.UP;
                if (this.keys['ArrowDown'] || this.keys['KeyS']) return DIRECTIONS.DOWN;
                if (this.keys['ArrowLeft'] || this.keys['KeyA']) return DIRECTIONS.LEFT;
                if (this.keys['ArrowRight'] || this.keys['KeyD']) return DIRECTIONS.RIGHT;

                return null;
            }

            handleInput() {
                if (this.gameOver || this.levelComplete) return;

                const allTanks = [this.player, ...this.enemies];
                const currentDirection = this.getCurrentDirection();

                if (currentDirection) {
                    this.player.move(currentDirection, this.map, allTanks);
                }

                if ((this.keys['Space'] || this.keys['Enter']) && this.player.canShoot) {
                    const bullet = this.player.shoot();
                    if (bullet) {
                        this.bullets.push(bullet);
                    }
                }

                this.debugInfo.textContent =
                    `Уровень: ${this.level} | Уничтожено: ${this.enemiesDestroyed}/${TOTAL_ENEMIES_PER_LEVEL} | ` +
                    `Осталось заспавнить: ${this.enemiesToSpawn} | FPS: ${Math.round(1000 / this.deltaTime)}`;
            }

            updateEnemies() {
                const allTanks = [this.player, ...this.enemies];

                this.enemies.forEach(enemy => {
                    enemy.update();

                    if (Math.random() < 0.03) {
                        const directions = Object.values(DIRECTIONS);
                        const randomDir = directions[Math.floor(Math.random() * directions.length)];
                        enemy.direction = randomDir;
                    }

                    enemy.move(enemy.direction, this.map, allTanks);

                    if (Math.random() < 0.015 && enemy.canShoot) {
                        const bullet = enemy.shoot();
                        if (bullet) {
                            this.bullets.push(bullet);
                        }
                    }
                });
            }

            updateBullets() {
                for (let i = this.bullets.length - 1; i >= 0; i--) {
                    for (let j = this.bullets.length - 1; j > i; j--) {
                        if (this.bullets[i].owner !== this.bullets[j].owner &&
                            this.bullets[i].getBounds().intersects(this.bullets[j].getBounds())) {
                            this.bulletExplosions.push(new BulletExplosion(this.bullets[i].position.x, this.bullets[i].position.y));
                            this.bullets.splice(i, 1);
                            this.bullets.splice(j, 1);
                            break;
                        }
                    }
                }

                for (let i = this.bullets.length - 1; i >= 0; i--) {
                    const bullet = this.bullets[i];
                    bullet.update();

                    const destructionResult = this.map.destroyTile(bullet.position.x, bullet.position.y);
                    if (destructionResult) {
                        if (destructionResult === 'base') {
                            this.explosions.push(new Explosion(bullet.position.x, bullet.position.y, 'base'));
                            this.screenShake = 30;
                        } else if (destructionResult === 'concrete' || destructionResult === 'brick') {
                            // Эффект разрушения пули при попадании в бетон или кирпич
                            this.bulletExplosions.push(new BulletExplosion(bullet.position.x, bullet.position.y));
                        }
                        this.bullets.splice(i, 1);
                        continue;
                    }

                    const bulletBounds = bullet.getBounds();

                    if (bullet.owner === 'player') {
                        for (let j = this.enemies.length - 1; j >= 0; j--) {
                            const enemy = this.enemies[j];
                            if (bulletBounds.intersects(enemy.getBounds())) {
                                if (enemy.takeDamage()) {
                                    this.explosions.push(new Explosion(enemy.position.x, enemy.position.y, 'tank'));
                                    this.screenShake = 10;

                                    this.enemies.splice(j, 1);
                                    this.enemiesDestroyed++;
                                    this.score += 100;
                                    this.updateUI();
                                }
                                this.bullets.splice(i, 1);
                                break;
                            }
                        }
                    } else {
                        if (bulletBounds.intersects(this.player.getBounds())) {
                            if (this.player.takeDamage()) {
                                this.explosions.push(new Explosion(this.player.position.x, this.player.position.y, 'tank'));
                                this.screenShake = 20;

                                this.lives--;
                                this.updateUI();
                                if (this.lives <= 0) {
                                    this.gameOver = true;
                                    this.showGameOver();
                                } else {
                                    // Респавн игрока с щитом
                                    this.player = new Tank(224, 750);
                                    this.player.activateShield();
                                }
                            }
                            this.bullets.splice(i, 1);
                        }
                    }

                    if (this.map.isBaseDestroyed()) {
                        this.gameOver = true;
                        this.showGameOver();
                    }

                    if (!bullet.active) {
                        this.bullets.splice(i, 1);
                    }
                }
            }

            updateRespawns() {
                const completedAnimations = [];
                this.spawnAnimations.forEach((animation, index) => {
                    animation.update(this.deltaTime);
                    if (!animation.active) {
                        completedAnimations.push(index);
                    }
                });

                completedAnimations.reverse().forEach(index => {
                    const spawnPoint = this.spawnAnimations[index].position;
                    this.completeSpawnAnimation(spawnPoint);
                    this.spawnAnimations.splice(index, 1);
                });

                const totalEnemiesOnScreen = this.enemies.length + this.spawnAnimations.length;
                if (totalEnemiesOnScreen < MAX_ENEMIES_ON_SCREEN && this.enemiesToSpawn > 0) {
                    const timeSinceLastRespawn = Date.now() - this.lastRespawnTime;
                    if (timeSinceLastRespawn >= RESPAWN_DELAY) {
                        this.spawnEnemy();
                        this.lastRespawnTime = Date.now();
                    }
                }

                if (this.enemiesDestroyed >= TOTAL_ENEMIES_PER_LEVEL &&
                    this.enemies.length === 0 &&
                    this.spawnAnimations.length === 0) {
                    this.showLevelComplete();
                }
            }

            updateShieldIndicator() {
                if (this.player.hasShield()) {
                    const remainingTime = this.player.shield.getRemainingTime();
                    this.shieldTime.textContent = remainingTime.toFixed(1);
                    this.shieldIndicator.style.display = 'block';
                } else {
                    this.shieldIndicator.style.display = 'none';
                }
            }

            showLevelComplete() {
                this.levelComplete = true;
                const levelCompleteScreen = document.getElementById('levelComplete');
                document.getElementById('destroyedTanks').textContent = this.enemiesDestroyed;
                document.getElementById('levelScore').textContent = this.score;
                levelCompleteScreen.style.display = 'block';
            }

            showGameOver() {
                const gameOverScreen = document.getElementById('gameOver');
                document.getElementById('finalScore').textContent = this.score;
                document.getElementById('finalLevel').textContent = this.level;
                gameOverScreen.style.display = 'block';
            }

            nextLevel() {
                this.level++;
                this.initLevel();
            }

            restartGame() {
                this.level = 1;
                this.score = 0;
                this.lives = 3;
                this.initLevel();
            }

            updateUI() {
                document.getElementById('score').textContent = this.score;
                document.getElementById('lives').textContent = this.lives;
                document.getElementById('level').textContent = this.level;
                document.getElementById('tanksLeft').textContent =
                    TOTAL_ENEMIES_PER_LEVEL - this.enemiesDestroyed;
            }

            updateExplosions() {
                for (let i = this.explosions.length - 1; i >= 0; i--) {
                    this.explosions[i].update(this.deltaTime);
                    if (!this.explosions[i].active) {
                        this.explosions.splice(i, 1);
                    }
                }

                for (let i = this.bulletExplosions.length - 1; i >= 0; i--) {
                    this.bulletExplosions[i].update();
                    if (!this.bulletExplosions[i].active) {
                        this.bulletExplosions.splice(i, 1);
                    }
                }
            }

            updateScreenShake() {
                if (this.screenShake > 0) {
                    this.screenShake--;
                    const shakeIntensity = this.screenShake * 0.5;
                    const offsetX = (Math.random() - 0.5) * shakeIntensity;
                    const offsetY = (Math.random() - 0.5) * shakeIntensity;
                    this.canvas.style.transform = `translate(${offsetX}px, ${offsetY}px)`;
                } else {
                    this.canvas.style.transform = 'translate(0, 0)';
                }
            }

            gameLoop(currentTime) {
                this.deltaTime = currentTime - this.lastTime;

                if (this.deltaTime >= FRAME_TIME) {
                    this.lastTime = currentTime - (this.deltaTime % FRAME_TIME);

                    this.handleInput();

                    if (!this.gameOver && !this.levelComplete) {
                        this.player.update();
                        this.updateEnemies();
                        this.updateBullets();
                        this.updateExplosions();
                        this.updateRespawns();
                        this.updateScreenShake();
                        this.updateShieldIndicator();
                    }

                    this.render();
                }

                requestAnimationFrame((time) => this.gameLoop(time));
            }

            render() {
                this.ctx.fillStyle = '#000';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                this.map.draw(this.ctx);

                this.spawnAnimations.forEach(animation => animation.draw(this.ctx));

                this.player.draw(this.ctx);
                this.enemies.forEach(enemy => enemy.draw(this.ctx));
                this.bullets.forEach(bullet => bullet.draw(this.ctx));
                this.explosions.forEach(explosion => explosion.draw(this.ctx));
                this.bulletExplosions.forEach(explosion => explosion.draw(this.ctx));
            }
        }

        let game;

        window.addEventListener('load', () => {
            game = new Game();
        });

        window.addEventListener('keydown', function(e) {
            if(['Space','ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.code)) {
                e.preventDefault();
            }
        }, false);
    </script>
</body>
</html>
